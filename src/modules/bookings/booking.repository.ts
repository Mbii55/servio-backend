// src/modules/bookings/booking.repository.ts
import pool from "../../config/database";
import { Booking, BookingStatus, BookingAddonInput } from "./booking.types";
import { getCommissionRateForProvider } from "../businessProfiles/businessProfile.repository";

export async function createBookingWithAddons(params: {
  customerId: string;
  serviceId: string;
  addressId?: string;
  scheduled_date: string; // "YYYY-MM-DD"
  scheduled_time: string; // "HH:MM"
  addons?: BookingAddonInput[];
  payment_method?: "cash" | "card" | "wallet";
  customer_notes?: string;
}): Promise<Booking> {
  const {
    customerId,
    serviceId,
    addressId,
    scheduled_date,
    scheduled_time,
    addons = [],
    payment_method = "cash",
    customer_notes,
  } = params;

  const client = await pool.connect();

  try {
    await client.query("BEGIN");

    // Get service info (includes provider_id and base_price)
    const serviceRes = await client.query<{
      id: string;
      provider_id: string;
      base_price: string;
    }>(
      `
      SELECT id, provider_id, base_price
      FROM services
      WHERE id = $1
      `,
      [serviceId]
    );

    const service = serviceRes.rows[0];
    if (!service) {
      throw new Error("Service not found");
    }

    const basePrice = Number(service.base_price);
    const providerId = service.provider_id;

    // Calculate addons price and prepare snapshots
    let addonsPrice = 0;
    type AddonRow = { id: string; name: string; price: string };

    let addonRows: AddonRow[] = [];

    if (addons.length > 0) {
      const addonIds = addons.map((a) => a.addon_id);
      const addonRes = await client.query<AddonRow>(
        `
        SELECT id, name, price
        FROM service_addons
        WHERE id = ANY($1::uuid[])
        `,
        [addonIds]
      );
      addonRows = addonRes.rows;

      for (const inputAddon of addons) {
        const dbAddon = addonRows.find((a) => a.id === inputAddon.addon_id);
        if (!dbAddon) continue;
        const qty = inputAddon.quantity ?? 1;
        addonsPrice += qty * Number(dbAddon.price);
      }
    }

    const subtotal = basePrice + addonsPrice;
    const commissionRate = await getCommissionRateForProvider(providerId);
    const commissionAmount = (subtotal * commissionRate) / 100;
    const providerEarnings = subtotal - commissionAmount;

    // Insert into bookings (booking_number generated by trigger)
    const bookingRes = await client.query<Booking>(
      `
      INSERT INTO bookings (
        customer_id,
        provider_id,
        service_id,
        address_id,
        scheduled_date,
        scheduled_time,
        status,
        service_price,
        addons_price,
        subtotal,
        commission_amount,
        provider_earnings,
        payment_method,
        payment_status,
        customer_notes
      )
      VALUES (
        $1,$2,$3,$4,$5,$6,
        'pending',
        $7,$8,$9,$10,$11,
        $12,
        'pending',
        $13
      )
      RETURNING *
      `,
      [
        customerId,
        providerId,
        serviceId,
        addressId ?? null,
        scheduled_date,
        scheduled_time,
        subtotal === 0 ? 0 : basePrice, // base service price
        addonsPrice,
        subtotal,
        commissionAmount,
        providerEarnings,
        payment_method,
        customer_notes ?? null,
      ]
    );

    const booking = bookingRes.rows[0];

    // Insert booking_addons snapshots
    if (addons.length > 0 && addonRows.length > 0) {
      for (const inputAddon of addons) {
        const dbAddon = addonRows.find((a) => a.id === inputAddon.addon_id);
        if (!dbAddon) continue;
        const qty = inputAddon.quantity ?? 1;

        await client.query(
          `
          INSERT INTO booking_addons (
            booking_id,
            addon_id,
            addon_name,
            addon_price,
            quantity
          )
          VALUES ($1,$2,$3,$4,$5)
          `,
          [
            booking.id,
            dbAddon.id,
            dbAddon.name,
            dbAddon.price,
            qty,
          ]
        );
      }
    }

    await client.query("COMMIT");
    return booking;
  } catch (err) {
    await client.query("ROLLBACK");
    throw err;
  } finally {
    client.release();
  }
}

export async function getBookingById(id: string): Promise<Booking | null> {
  const res = await pool.query<Booking>(
    `SELECT * FROM bookings WHERE id = $1 LIMIT 1`,
    [id]
  );
  return res.rows[0] || null;
}

export async function listBookingsForUser(userId: string, role: "customer" | "provider" | "admin"): Promise<Booking[]> {
  if (role === "admin") {
    const res = await pool.query<Booking>(
      `
      SELECT *
      FROM bookings
      ORDER BY created_at DESC
      `
    );
    return res.rows;
  }

  const column = role === "customer" ? "customer_id" : "provider_id";

  const res = await pool.query<Booking>(
    `
    SELECT *
    FROM bookings
    WHERE ${column} = $1
    ORDER BY created_at DESC
    `,
    [userId]
  );
  return res.rows;
}

const VALID_TRANSITIONS: Record<BookingStatus, BookingStatus[]> = {
  pending: ["accepted", "rejected", "cancelled"],
  accepted: ["in_progress", "cancelled"],
  in_progress: ["completed", "cancelled"],
  completed: [],
  cancelled: [],
  rejected: [],
};

export async function updateBookingStatus(
  id: string,
  newStatus: BookingStatus,
  options: {
    cancellation_reason?: string;
    provider_notes?: string;
  }
): Promise<Booking | null> {
  const existingRes = await pool.query<Booking>(
    `SELECT * FROM bookings WHERE id = $1 LIMIT 1`,
    [id]
  );
  const existing = existingRes.rows[0];
  if (!existing) return null;

  const allowed = VALID_TRANSITIONS[existing.status] || [];
  if (!allowed.includes(newStatus)) {
    throw new Error(`Invalid status transition from ${existing.status} to ${newStatus}`);
  }

  const { cancellation_reason, provider_notes } = options;

  const setParts: string[] = ["status = $1"];
  const values: any[] = [newStatus];
  let index = 2;

  if (cancellation_reason !== undefined) {
    setParts.push(`cancellation_reason = $${index++}`);
    values.push(cancellation_reason);
  }

  if (provider_notes !== undefined) {
    setParts.push(`provider_notes = $${index++}`);
    values.push(provider_notes);
  }

  // timestamps depending on newStatus
  if (newStatus === "accepted") {
    setParts.push(`accepted_at = CURRENT_TIMESTAMP`);
  }
  if (newStatus === "in_progress") {
    setParts.push(`started_at = CURRENT_TIMESTAMP`);
  }
  if (newStatus === "completed") {
    setParts.push(`completed_at = CURRENT_TIMESTAMP`);
  }
  if (newStatus === "cancelled") {
    setParts.push(`cancelled_at = CURRENT_TIMESTAMP`);
  }

  const query = `
    UPDATE bookings
    SET ${setParts.join(", ")}
    WHERE id = $${index}
    RETURNING *
  `;
  values.push(id);

  const res = await pool.query<Booking>(query, values);
  return res.rows[0] || null;
}
